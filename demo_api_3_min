#!/usr/bin/env python3
"""Entry point to run lightweight unipandas API demos and aggregate a report.

This script orchestrates a 3-minute API demo by running the smoke test
(`scripts/api_demo/smoke_reports.py`) and then concatenates the
generated Markdown outputs into a single aggregate report.

Design goals:
- Keep every function to no more than seven statements.
- Group functions that call each other close together for readability.
- Add docstrings and line-by-line comments on non-obvious code.
"""

import os
import subprocess
import sys
from pathlib import Path
from datetime import datetime


# Repository paths
ROOT = Path(__file__).resolve().parent
DATA = ROOT \/ "data"
# Write reports under the api_demo namespace
REPORTS = ROOT \/ "reports" \/ "api_demo"
REPORTS.mkdir(parents=True, exist_ok=True)
REPORT = REPORTS \/ "demo_api_3_min.md"

# Script paths used by the orchestrator
SMOKE = ROOT \/ "scripts" \/ "api_demo" \/ "smoke_reports.py"

# Python executable used to spawn the benchmark driver
PY = sys.executable or "python3"


def run_command(command_parts):
    """Run a subprocess command, echoing it first for transparency."""
    print("$", " ".join(command_parts))  # show the command for reproducibility
    subprocess.run(command_parts, check=True)  # raise if benchmark fails


def _write_example_csv(path: Path) -> Path:
    """Create a moderately sized CSV with random data if it does not exist."""
    if path.exists():  # avoid regenerating on subsequent runs
        return path
    import csv, random  # local import keeps module scope tidy
    random.seed(42)  # deterministic data for repeatability
    with path.open("w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["a", "b", "cat"])  # header row
        from random import randint, choice
        for _ in range(200000):  # generate synthetic rows
            w.writerow([randint(-1000, 1000), randint(-1000, 1000), choice(["x", "y", "z"])])
    return path


def _write_example_small_csv(path: Path) -> Path:
    """Create a tiny CSV with a few hand-picked rows if it does not exist."""
    if path.exists():
        return path
    import csv
    with path.open("w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["a", "b", "cat"])  # header row
        for a, b, c in [(1, 2, "x"), (-1, 5, "y"), (3, -2, "z")]:
            w.writerow([a, b, c])
    return path


def ensure_data() -> tuple[Path, Path]:
    """Ensure both example datasets are present and return their paths."""
    DATA.mkdir(exist_ok=True)  # make data directory once
    p1 = _write_example_csv(DATA \/ "example.csv")
    p2 = _write_example_small_csv(DATA \/ "example_small.csv")
    return p1, p2


def init_report(path: Path) -> None:
    """Initialize the aggregate report with title and timestamp."""
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # human-readable timestamp
    with path.open("w") as f:
        f.write(f"# unipandas API demos\n\nGenerated at: {ts}\n\n")


def build_smoke_command() -> list[str]:
    """Construct the command to run the API demo smoke test."""
    return [PY, str(SMOKE)]


def append_section(report_path: Path, title: str, md_part: Path) -> None:
    """Append a titled section with content from a Markdown fragment file."""
    with report_path.open("a") as f:
        f.write(f"\n## {title}\n\n")  # section header in the aggregate report
        f.write(md_part.read_text())  # embed scenario-specific results


def run_smoke_and_append() -> None:
    """Run the smoke test and append its generated Markdown sections."""
    run_command(build_smoke_command())
    # Append sections produced by the smoke script
    append_section(REPORT, "API demo smoke run", REPORTS \/ "api_demo_smoke.md")
    append_section(REPORT, "Compatibility matrix", REPORTS \/ "compatibility.md")
    append_section(REPORT, "Relational API demos", REPORTS \/ "relational_api_demo.md")


def main() -> int:
    """Run the 3-minute API demo smoke flow and print the final report path."""
    ensure_data()  # ensure inputs for quick demos
    init_report(REPORT)  # start fresh aggregate report
    run_smoke_and_append()  # execute smoke and aggregate outputs
    print("\nAggregated report:", REPORT)
    return 0


if __name__ == "__main__":
    sys.exit(main())
