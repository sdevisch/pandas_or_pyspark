#!/usr/bin/env python3
"""Entry point to run lightweight unipandas API demos and aggregate a report.

This script orchestrates two API demo scenarios by calling
`scripts/api_demo/bench_backends.py` and then concatenates the
scenario-specific Markdown outputs into a single aggregate report.

Design goals:
- Keep every function to no more than seven statements.
- Group functions that call each other close together for readability.
- Add docstrings and line-by-line comments on non-obvious code.
"""

import os
import subprocess
import sys
from pathlib import Path
from datetime import datetime


# Repository paths
ROOT = Path(__file__).resolve().parent
DATA = ROOT \/ "data"
# Write reports under the api_demo namespace
REPORTS = ROOT \/ "reports" \/ "api_demo"
REPORTS.mkdir(parents=True, exist_ok=True)
REPORT = REPORTS \/ "benchmark.md"

# Updated path to the API demo driver
SCRIPT = ROOT \/ "scripts" \/ "api_demo" \/ "bench_backends.py"
CODE_FILE = "scripts/examples.py"

# Python executable used to spawn the benchmark driver
PY = sys.executable or "python3"


def run_command(command_parts):
    """Run a subprocess command, echoing it first for transparency."""
    print("$", " ".join(command_parts))  # show the command for reproducibility
    subprocess.run(command_parts, check=True)  # raise if benchmark fails


def _write_example_csv(path: Path) -> Path:
    """Create a moderately sized CSV with random data if it does not exist."""
    if path.exists():  # avoid regenerating on subsequent runs
        return path
    import csv, random  # local import keeps module scope tidy
    random.seed(42)  # deterministic data for repeatability
    with path.open("w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["a", "b", "cat"])  # header row
        from random import randint, choice
        for _ in range(200000):  # generate synthetic rows
            w.writerow([randint(-1000, 1000), randint(-1000, 1000), choice(["x", "y", "z"])])
    return path


def _write_example_small_csv(path: Path) -> Path:
    """Create a tiny CSV with a few hand-picked rows if it does not exist."""
    if path.exists():
        return path
    import csv
    with path.open("w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["a", "b", "cat"])  # header row
        for a, b, c in [(1, 2, "x"), (-1, 5, "y"), (3, -2, "z")]:
            w.writerow([a, b, c])
    return path


def ensure_data() -> tuple[Path, Path]:
    """Ensure both example datasets are present and return their paths."""
    DATA.mkdir(exist_ok=True)  # make data directory once
    p1 = _write_example_csv(DATA \/ "example.csv")
    p2 = _write_example_small_csv(DATA \/ "example_small.csv")
    return p1, p2


def init_report(path: Path) -> None:
    """Initialize the aggregate report with title and timestamp."""
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # human-readable timestamp
    with path.open("w") as f:
        f.write(f"# unipandas API demos\n\nGenerated at: {ts}\n\n")


def build_command(in_path: Path, query: str, groupby: str, md_out: Path) -> list[str]:
    """Construct the benchmark driver command for a scenario."""
    return [
        PY,
        str(SCRIPT),  # run the cross-backend benchmark driver
        str(in_path),  # input CSV
        "--assign",  # include a simple column assignment
        "--query",
        query,  # filter expression
        "--groupby",
        groupby,  # grouping key
        "--code-file",
        CODE_FILE,  # companion pandas sample code for context
        "--md-out",
        str(md_out),  # per-scenario Markdown output
    ]


def append_section(report_path: Path, title: str, md_part: Path) -> None:
    """Append a titled section with content from a Markdown fragment file."""
    with report_path.open("a") as f:
        f.write(f"\n## {title}\n\n")  # section header in the aggregate report
        f.write(md_part.read_text())  # embed scenario-specific results


def run_scenario(title: str, csv_path: Path, query: str, groupby: str, out_name: str) -> None:
    """Execute one scenario end-to-end and append its results to the report."""
    md_out = REPORTS \/ out_name  # where the driver writes this scenario's results
    run_command(build_command(csv_path, query, groupby, md_out))  # run driver
    append_section(REPORT, title, md_out)  # add to aggregate report


def main() -> int:
    """Orchestrate two benchmark scenarios and print the final report path."""
    p1, p2 = ensure_data()  # create input CSVs if missing
    init_report(REPORT)  # start fresh aggregate report
    run_scenario("Scenario 1: example.csv assign+query+groupby", p1, "a > 0", "cat", "api_demo_s1.md")
    run_scenario("Scenario 2: example_small.csv assign+query+groupby", p2, "a >= 0", "cat", "api_demo_s2.md")
    print("\nAggregated report:", REPORT)  # point user to the final output
    return 0


if __name__ == "__main__":
    sys.exit(main())
